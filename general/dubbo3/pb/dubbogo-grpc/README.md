# Triple-Grpc interactive example

## Example structure

In this example, we provide proto protocol, server, unary RPC client, streaming rpc client for triple and grpc respectively.

Any group of client and server can be used interchangeably to implement RPC calls.

## Triple service start

### pb generation
1. First write the proto file

```protobuf
syntax = "proto3";

option go_package = "protobuf/dubbo3";
package protobuf;

// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (User) {}
  rpc SayHelloStream (stream HelloRequest) returns (stream User) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message User {
  string name = 1;
  string id = 2;
  int32 age = 3;
}

```
2. Install the protoc cli tool
    
3. Install protoc-gen-dubbo3 (used to generate a stub suitable for triple)    
```shell
    go get -u dubbo.apache.org/dubbo-go/v3/protocol/dubbo3/protoc-gen-dubbo3@3.0
```

4. generate pb file
```shell
    protoc -I . helloworld.proto --dubbo3_out=plugins=grpc+dubbo:.
```

### Server start
1. Provider structure definition
```go
package pkg

import (
    "context"
    "fmt"
)

import (
    "dubbo.apache.org/dubbo-go/v3/common/logger"
)

import (
    dubbo3 "github.com/apache/dubbo-go-samples/general/dubbo3/pb/dubbogo-grpc/protobuf/dubbo3"
)

type GreeterProvider struct {
// Introduce dubbo3 provider base
    *dubbo3.GreeterProviderBase
}

func NewGreeterProvider() *GreeterProvider {
    return &GreeterProvider{// Initialize base with the instance in the generated pb
        GreeterProviderBase: &dubbo3.GreeterProviderBase{},
    }
}
// SayHelloStream provides functions for streaming RPC calls
func (s *GreeterProvider) SayHelloStream(svr dubbo3.Greeter_SayHelloStreamServer) error {
    c, err := svr.Recv()
    if err != nil {
        return err
    }
    logger.Infof("Dubbo-go3 GreeterProvider recv 1 user, name = %s\n", c.Name)
    c2, err := svr.Recv()
    if err != nil {
        return err
    }
    logger.Infof("Dubbo-go3 GreeterProvider recv 2 user, name = %s\n", c2.Name)
    c3, err := svr.Recv()
    if err != nil {
        return err
    }
    logger.Infof("Dubbo-go3 GreeterProvider recv 3 user, name = %s\n", c3.Name)
    
    svr.Send(&dubbo3.User{
        Name: "hello "+ c.Name,
        Age: 18,
        Id: "123456789",
    })
    svr.Send(&dubbo3.User{
        Name: "hello "+ c2.Name,
        Age: 19,
        Id: "123456789",
    })
    return nil
}

// SayHello provides service functions called by ordinary rpc
func (s *GreeterProvider) SayHello(ctx context.Context, in *dubbo3.HelloRequest) (*dubbo3.User, error) {
    logger.Infof("Dubbo3 GreeterProvider get user name = %s\n" + in.Name)
    fmt.Println("get triple header tri-req-id = ", ctx.Value("tri-req-id"))
    fmt.Println("get triple header tri-service-version = ", ctx.Value("tri-service-version"))
    return &dubbo3.User{Name: "Hello "+ in.Name, Id: "12345", Age: 21}, nil
}

// Reference needs to correspond to the Reference key in config
func (g *GreeterProvider) Reference() string {
    return "GreeterProvider"
}
```
2. Configuration file
   server/dubbogo-server/conf/server.yml
```yaml
# service config
services:
  "GreeterProvider":
    registry: "demoZK"
    protocol: "tri" # Use triple protocol
    interface: "protobuf.Greeter" # Same as the interface name generated by grpc, as follows
```

The interface name of the Grpc pb file can be seen as protobuf.Greeter, which is defined by the user as required.
In order for triple-go to get through with grpc, it must be the same as the grpc interface name and correctly configured in the yaml file.

protobuf/grpc/helloworld.pb.go:
```go
func (c *greeterClient) SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*User, error) {
    out := new(User)
    err := c.cc.Invoke(ctx, "/protobuf.Greeter/SayHello", in, out, opts...)
    if err != nil {
        return nil, err
    }
    return out, nil
}
```

3. Start the server

goland run
triple/triple-server

## Client (take ordinary rpc call as an example, the same for streaming RPC)

1. Consumer end structure definition
   The Consumer structure has been implemented in the pb file and can be imported directly
```go
import (
    dubbo3pb "github.com/apache/dubbo-go-samples/general/dubbo3/pb/dubbogo-grpc/protobuf/dubbo3"
)

// Directly introduce the GreeterClientImpl structure, you can enter the structure, and see the Reference as "greeterImpl"
var greeterProvider = new(dubbo3pb.GreeterClientImpl)

func init() {
    config.SetConsumerService(greeterProvider)
}
```

The corresponding reference key is defined in the configuration file
```yaml
# reference config
references:
  "greeterImpl":
    registry: "demoZk"
    protocol: "tri"
    interface: "protobuf.Greeter"
    url: tri://localhost:20001
```

2. Start the client

goland run
triple/triple-unary-client